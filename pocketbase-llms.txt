# PocketBase Complete Documentation

PocketBase documentation optimized for AI-assisted development. Comprehensive reference covering core platform features, JavaScript SDK, and server-side scripting capabilities.

---

## Table of Contents

1. [Introduction](#introduction)
2. [Installation and Setup](#installation-and-setup)
3. [Collections](#collections)
4. [API Rules and Security](#api-rules-and-security)
5. [JavaScript SDK](#javascript-sdk)
6. [Authentication](#authentication)
7. [CRUD Operations](#crud-operations)
8. [File Management](#file-management)
9. [Realtime Subscriptions](#realtime-subscriptions)
10. [Server-side JavaScript (JSVM)](#server-side-javascript-jsvm)
11. [Deployment](#deployment)
12. [Advanced Configuration](#advanced-configuration)

---

## Introduction

PocketBase is an **"Open Source backend in 1 file"** with the following key features:

- **Embedded SQLite database** with automatic migrations
- **Realtime subscriptions** (server-sent events and WebSocket)
- **Built-in auth management** with multiple providers
- **Convenient dashboard UI** for admin operations
- **Simple REST-ish API** with flexible rules
- **Server-side JavaScript extensions** (JSVM) for custom logic

### Core Architecture

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Client App    │◄──►│   PocketBase     │◄──►│   SQLite DB     │
│                 │    │                  │    │                 │
│ - Web/Mobile    │    │ - REST API       │    │ - Collections   │
│ - JavaScript    │    │ - Auth System    │    │ - Relations     │
│ - Realtime      │    │ - File Storage   │    │ - Migrations    │
│ - File Upload   │    │ - Admin UI       │    │ - Backups       │
└─────────────────┘    │ - JSVM Hooks     │    └─────────────────┘
                       └──────────────────┘
```

---

## Installation and Setup

### Download and Install

1. **Download** the appropriate executable from [releases](https://github.com/pocketbase/pocketbase/releases)
2. **Extract** the archive
3. **Run** the executable:

```bash
# Start the server
./pocketbase serve

# Custom port and directory
./pocketbase serve --http=127.0.0.1:8091 --dir=/path/to/pb_data
```

### Default Routes

Once started, PocketBase exposes several routes:

- **Static files**: `http://127.0.0.1:8090/`
- **Admin dashboard**: `http://127.0.0.1:8090/_/`
- **REST API**: `http://127.0.0.1:8090/api/`

### Directory Structure

```
your-app/
├── pocketbase              # The executable
├── pb_data/                # Data directory (auto-created)
│   ├── data.db            # SQLite database
│   ├── logs.db            # Request logs
│   └── storage/           # Uploaded files
├── pb_migrations/          # Database migrations (optional)
│   └── *.js               # Migration files
└── pb_hooks/              # Server-side JS (optional)
    └── *.pb.js            # Hook files
```

---

## Collections

Collections are the primary way to organize your data in PocketBase. There are 3 types:

### 1. Base Collection
Standard data storage with CRUD operations.

```javascript
// Example: Posts collection
{
  "name": "posts",
  "type": "base",
  "schema": [
    {
      "name": "title",
      "type": "text",
      "required": true
    },
    {
      "name": "content",
      "type": "editor"
    },
    {
      "name": "status",
      "type": "select",
      "options": {
        "values": ["draft", "published", "archived"]
      }
    }
  ]
}
```

### 2. Auth Collection
User management with built-in authentication features.

```javascript
// Example: Users collection
{
  "name": "users",
  "type": "auth",
  "options": {
    "allowEmailAuth": true,
    "allowUsernameAuth": false,
    "requireEmail": true
  },
  "schema": [
    {
      "name": "name",
      "type": "text"
    },
    {
      "name": "avatar",
      "type": "file",
      "options": {
        "maxSelect": 1,
        "maxSize": 5242880,
        "mimeTypes": ["image/jpeg", "image/png"]
      }
    }
  ]
}
```

### 3. View Collection
Read-only collections generated from SQL queries.

```javascript
// Example: Analytics view
{
  "name": "user_stats",
  "type": "view",
  "options": {
    "query": "SELECT users.id, users.name, COUNT(posts.id) as posts_count FROM users LEFT JOIN posts ON users.id = posts.author GROUP BY users.id"
  }
}
```

### Field Types

PocketBase supports various field types:

| Type | Description | Options |
|------|-------------|---------|
| `text` | Single line text | `min`, `max`, `pattern` |
| `number` | Integer or float | `min`, `max` |
| `bool` | Boolean true/false | - |
| `email` | Email validation | `exceptDomains`, `onlyDomains` |
| `url` | URL validation | `exceptDomains`, `onlyDomains` |
| `date` | Date only | `min`, `max` |
| `select` | Single select | `values` (array) |
| `json` | JSON data | `maxSize` |
| `file` | File uploads | `maxSelect`, `maxSize`, `mimeTypes` |
| `relation` | Record relations | `collectionId`, `cascadeDelete` |
| `user` | User relation | Deprecated, use `relation` |
| `editor` | Rich text | `convertUrls` |

---

## API Rules and Security

API Rules control access to your data using JavaScript-like expressions.

### Rule Types

Each collection has 5 rule types:

1. **listRule**: Controls who can list/search records
2. **viewRule**: Controls who can view individual records  
3. **createRule**: Controls who can create new records
4. **updateRule**: Controls who can update existing records
5. **deleteRule**: Controls who can delete records

### Rule Context Variables

| Variable | Description |
|----------|-------------|
| `@request.method` | HTTP method (GET, POST, etc.) |
| `@request.query.*` | Query parameters |
| `@request.data.*` | Request body data |
| `@request.auth.*` | Authenticated user data |
| `@collection.*` | Current collection data |

### Example Rules

```javascript
// Public read, auth required for write
"listRule": "",                           // Anyone can list
"viewRule": "",                           // Anyone can view
"createRule": "@request.auth.id != ''",   // Must be authenticated
"updateRule": "@request.auth.id != ''",   // Must be authenticated
"deleteRule": "@request.auth.id != ''",   // Must be authenticated

// User can only manage their own records
"listRule": "@request.auth.id != ''",
"viewRule": "@request.auth.id != '' && author = @request.auth.id",
"createRule": "@request.auth.id != '' && @request.data.author = @request.auth.id",
"updateRule": "@request.auth.id != '' && author = @request.auth.id",
"deleteRule": "@request.auth.id != '' && author = @request.auth.id",

// Admin-only access
"listRule": "@request.auth.role = 'admin'",
"viewRule": "@request.auth.role = 'admin'",
"createRule": "@request.auth.role = 'admin'",
"updateRule": "@request.auth.role = 'admin'",
"deleteRule": "@request.auth.role = 'admin'",

// Complex conditions
"listRule": "@request.auth.id != '' && (status = 'published' || author = @request.auth.id)",
"createRule": "@request.auth.verified = true && @request.data.title != ''",
"updateRule": "@request.auth.id != '' && author = @request.auth.id && @request.data.title != ''"
```

---

## JavaScript SDK

The PocketBase JavaScript SDK provides a convenient way to interact with your PocketBase instance.

### Installation

```bash
# npm
npm install pocketbase

# yarn  
yarn add pocketbase

# CDN
<script type="module">
import PocketBase from 'https://cdn.skypack.dev/pocketbase'
</script>
```

### Basic Usage

```javascript
import PocketBase from 'pocketbase';

const pb = new PocketBase('http://127.0.0.1:8090');
```

### Configuration Options

```javascript
const pb = new PocketBase('http://127.0.0.1:8090', {
    // optional default fetch options
    headers: {
        'Custom-Header': 'value'
    },
    // custom fetch function
    fetch: async (url, config) => {
        return nativeFetch(url, config);
    }
});
```

---

## Authentication

PocketBase supports multiple authentication methods for auth collections.

### Password Authentication

```javascript
// Register new user
const userData = {
    "email": "test@example.com",
    "password": "12345678",
    "passwordConfirm": "12345678", 
    "name": "John Doe"
};

const user = await pb.collection('users').create(userData);

// Login with email/password
const authData = await pb.collection('users').authWithPassword('test@example.com', '12345678');

console.log(pb.authStore.isValid);     // true
console.log(pb.authStore.token);       // JWT token
console.log(pb.authStore.model.id);    // User record data
```

### OAuth2 Authentication

```javascript
// Authenticate with OAuth2 provider
const authData = await pb.collection('users').authWithOAuth2('google');

// Available providers include:
// google, facebook, github, gitlab, discord, twitter,
// microsoft, spotify, kakao, twitch, strava, gitee, livechat
```

### Authentication Management

```javascript
// Check if authenticated
console.log(pb.authStore.isValid);

// Get current user
console.log(pb.authStore.model);

// Refresh authentication  
await pb.collection('users').authRefresh();

// Logout
pb.authStore.clear();

// Auth store change listener
pb.authStore.onChange((token, model) => {
    console.log('auth changed', token, model);
});
```

### Email Verification

```javascript
// Request verification email
await pb.collection('users').requestVerification('test@example.com');

// Confirm verification
await pb.collection('users').confirmVerification('VERIFICATION_TOKEN');
```

### Password Reset

```javascript
// Request password reset
await pb.collection('users').requestPasswordReset('test@example.com');

// Confirm password reset
await pb.collection('users').confirmPasswordReset(
    'PASSWORD_RESET_TOKEN',
    'NEW_PASSWORD',
    'NEW_PASSWORD_CONFIRM'
);
```

---

## CRUD Operations

### Create Records

```javascript
// Simple create
const record = await pb.collection('posts').create({
    "title": "Hello World",
    "content": "This is my first post"
});

// Create with file upload
const formData = new FormData();
formData.append('title', 'Post with image');
formData.append('content', 'Content here');
formData.append('featured_image', fileInput.files[0]);

const record = await pb.collection('posts').create(formData);
```

### Read Records

```javascript
// Get single record by ID
const record = await pb.collection('posts').getOne('RECORD_ID');

// Get single record with query options
const record = await pb.collection('posts').getOne('RECORD_ID', {
    expand: 'author,category',
    fields: 'id,title,content,expand.author.name'
});

// List records with pagination
const resultList = await pb.collection('posts').getList(1, 20, {
    filter: 'status = "published" && created >= "2023-01-01"',
    sort: '-created,title',
    expand: 'author',
    fields: 'id,title,author,expand.author.name'
});

console.log(resultList.page);        // Current page
console.log(resultList.perPage);     // Records per page  
console.log(resultList.totalItems);  // Total records
console.log(resultList.totalPages);  // Total pages
console.log(resultList.items);       // Array of records

// Get all records (auto-pagination)
const records = await pb.collection('posts').getFullList({
    sort: '-created',
    filter: 'status = "published"'
});

// Get first record matching filter
const record = await pb.collection('posts').getFirstListItem('title="Hello World"');
```

### Update Records

```javascript
// Simple update
const record = await pb.collection('posts').update('RECORD_ID', {
    "title": "Updated title",
    "status": "published"
});

// Update with file upload
const formData = new FormData();
formData.append('title', 'Updated title');
formData.append('featured_image', newFileInput.files[0]);

const record = await pb.collection('posts').update('RECORD_ID', formData);

// Partial update (only changed fields)
const record = await pb.collection('posts').update('RECORD_ID', {
    "status": "archived"
});
```

### Delete Records

```javascript
// Delete single record
await pb.collection('posts').delete('RECORD_ID');

// Delete with confirmation
const confirmed = confirm('Are you sure?');
if (confirmed) {
    await pb.collection('posts').delete('RECORD_ID');
}
```

### Query Options

All read operations support these query options:

```javascript
const options = {
    // Expand relations
    expand: 'author,category,comments(limit:10)',
    
    // Select specific fields
    fields: 'id,title,content,expand.author.name',
    
    // Filter records (supports various operators)
    filter: 'status = "published" && created >= "2023-01-01" && author.verified = true',
    
    // Sort records (- for descending)
    sort: '-created,title,author.name',
    
    // Pagination
    page: 1,
    perPage: 20,
    
    // Skip total count (faster for large datasets)
    skipTotal: true,
    
    // Custom headers
    headers: {
        'X-Custom': 'value'
    },
    
    // Request key for auto-cancellation
    requestKey: 'unique-request-id'
};
```

### Filter Operators

```javascript
// Comparison operators
'age > 18'                    // Greater than
'age >= 18'                   // Greater than or equal
'age < 65'                    // Less than  
'age <= 65'                   // Less than or equal
'status = "active"'           // Equal
'status != "inactive"'        // Not equal

// Text operators  
'title ~ "hello"'             // Contains (case insensitive)
'title !~ "spam"'             // Doesn't contain
'email ?= "example.com"'      // Ends with
'name ?~ "john"'              // Like (case insensitive)

// Array/relation operators
'tags:each ~ "javascript"'    // Each array item contains
'categories.id ?= "cat1"'     // Related record field
'author.verified = true'      // Expanded relation field

// Logical operators
'status = "active" && age > 18'                    // AND
'type = "premium" || type = "gold"'                // OR  
'!(status = "banned" || status = "suspended")'     // NOT

// Date/time
'created >= "2023-01-01"'                         // Date comparison
'updated > "2023-01-01 10:00:00"'                 // DateTime comparison
'created >= @now'                                 // Current time
'created >= @todayStart'                          // Today start
'created >= @monthStart'                          // Month start

// Complex examples
'(status = "published" && featured = true) || (status = "featured")'
'tags:each ~ "react" && author.verified = true && created >= "2023-01-01"'
'title ~ @request.query.search || content ~ @request.query.search'
```

---

## File Management

PocketBase handles file uploads and provides convenient methods for file operations.

### File Upload

```javascript
// Single file upload
const formData = new FormData();
formData.append('title', 'My document');
formData.append('document', fileInput.files[0]);

const record = await pb.collection('documents').create(formData);

// Multiple file upload (if field allows multiple)
const formData = new FormData();
formData.append('title', 'Photo gallery');
for (let file of fileInput.files) {
    formData.append('photos', file);
}

const record = await pb.collection('galleries').create(formData);

// Update with new file
const formData = new FormData();
formData.append('title', 'Updated title');
formData.append('document', newFileInput.files[0]);

const record = await pb.collection('documents').update('RECORD_ID', formData);
```

### File URLs

```javascript
// Get file URL
const record = await pb.collection('documents').getOne('RECORD_ID');
const fileUrl = pb.files.getUrl(record, 'document');

// Example: http://127.0.0.1:8090/api/files/documents/RECORD_ID/filename.pdf

// File URL with thumb (for images)
const thumbUrl = pb.files.getUrl(record, 'photo', {'thumb': '100x100'});

// Custom query parameters
const fileUrl = pb.files.getUrl(record, 'document', {
    'download': 1,                    // Force download
    'token': pb.authStore.token       // Auth token for protected files
});
```

### File Field Configuration

```javascript
// File field options in collection schema
{
    "name": "attachments", 
    "type": "file",
    "options": {
        "maxSelect": 5,                           // Max number of files
        "maxSize": 5242880,                       // Max size per file (5MB)
        "mimeTypes": [                            // Allowed file types
            "image/jpeg",
            "image/png", 
            "application/pdf",
            "text/plain"
        ],
        "thumbs": [                               // Image thumbnail sizes
            "100x100",
            "200x200", 
            "300x300f"                            // f = fit, t = top, b = bottom
        ]
    }
}
```

### File Deletion

```javascript
// Files are automatically deleted when:
// 1. The record is deleted
// 2. The file field is updated/cleared  
// 3. The record is updated with new files (old files are removed)

// Clear file field
await pb.collection('documents').update('RECORD_ID', {
    "document": null  // or empty string ""
});

// Update with new file (old file will be deleted)
const formData = new FormData();
formData.append('document', newFile);
await pb.collection('documents').update('RECORD_ID', formData);
```

---

## Realtime Subscriptions

PocketBase supports realtime updates via Server-Sent Events (SSE) and WebSocket.

### Basic Subscription

```javascript
// Subscribe to all changes in a collection
pb.collection('posts').subscribe('*', function (e) {
    console.log(e.action);    // create, update, delete
    console.log(e.record);    // the changed record
});

// Subscribe to specific record
pb.collection('posts').subscribe('RECORD_ID', function (e) {
    console.log('Record updated:', e.record);
});

// Subscribe with options
pb.collection('posts').subscribe('*', function (e) {
    console.log(e.action, e.record);
}, {
    expand: 'author,category',
    fields: 'id,title,content,expand.author.name',
    headers: {
        'X-Custom': 'value'
    }
});
```

### Advanced Subscription Examples

```javascript
// Multiple subscriptions
pb.collection('posts').subscribe('*', handlePostChanges);
pb.collection('comments').subscribe('*', handleCommentChanges);
pb.collection('users').subscribe(currentUserId, handleUserChanges);

// Subscription with error handling
pb.collection('posts').subscribe('*', function (e) {
    try {
        updateUI(e.record);
    } catch (error) {
        console.error('Failed to update UI:', error);
    }
}).catch(error => {
    console.error('Subscription failed:', error);
});

// Conditional subscription
if (pb.authStore.isValid) {
    pb.collection('notifications').subscribe('*', function (e) {
        if (e.record.user === pb.authStore.model.id) {
            showNotification(e.record);
        }
    });
}
```

### Unsubscribe

```javascript
// Unsubscribe from specific record
pb.collection('posts').unsubscribe('RECORD_ID');

// Unsubscribe from all changes in collection
pb.collection('posts').unsubscribe('*');

// Unsubscribe from everything
pb.collection('posts').unsubscribe();

// Store subscription for later cleanup
const unsubscribe = pb.collection('posts').subscribe('*', handleChanges);

// Later...
unsubscribe();
```

### Subscription Events

```javascript
// Event object structure
{
    "action": "create",        // create, update, delete
    "record": {                // the changed record data
        "id": "RECORD_ID",
        "title": "Hello World",
        "created": "2023-01-01 12:00:00",
        "updated": "2023-01-01 12:00:00",
        // ... other fields
    }
}

// Handling different actions
pb.collection('posts').subscribe('*', function (e) {
    switch (e.action) {
        case 'create':
            addPostToList(e.record);
            break;
        case 'update':
            updatePostInList(e.record);
            break;
        case 'delete':
            removePostFromList(e.record);
            break;
    }
});
```

### Connection Management

```javascript
// Check realtime connection status
console.log(pb.realtime.isConnected);

// Connection event listeners
pb.realtime.subscribe('PB_CONNECT', function () {
    console.log('Connected to realtime');
});

pb.realtime.subscribe('PB_DISCONNECT', function () {
    console.log('Disconnected from realtime');
});

// Manual connection control
await pb.realtime.subscribe('posts', '*', handleChanges);
pb.realtime.unsubscribe();  // Disconnect from all subscriptions
```

---

## Server-side JavaScript (JSVM)

PocketBase supports server-side JavaScript execution through its JavaScript Virtual Machine (JSVM). This allows you to extend PocketBase with custom logic, API endpoints, and event handlers.

### Setup

1. Create a `pb_hooks` directory in your PocketBase root
2. Add `.pb.js` files to define your server-side logic
3. PocketBase automatically loads and executes these files on startup

```
your-app/
├── pocketbase
├── pb_data/
└── pb_hooks/              # Server-side JavaScript files
    ├── main.pb.js         # Main hooks
    ├── auth.pb.js         # Authentication hooks  
    └── api.pb.js          # Custom API routes
```

### JavaScript Environment

- **Engine**: Goja (ES5+ JavaScript)
- **Execution**: Isolated contexts per handler
- **Performance**: Pool of 15 runtimes (configurable with `--hooksPool`)
- **Modules**: CommonJS-style require() support

### Custom API Routes

```javascript
// pb_hooks/api.pb.js

// Simple GET route
routerAdd("GET", "/api/hello", (e) => {
    return e.json(200, {"message": "Hello from PocketBase!"});
});

// Route with path parameters
routerAdd("GET", "/api/hello/{name}", (e) => {
    const name = e.request.pathValue("name");
    return e.json(200, {"message": `Hello ${name}!`});
});

// POST route with JSON body
routerAdd("POST", "/api/contact", (e) => {
    const data = new DynamicModel({
        name: "",
        email: "",
        message: ""
    });
    
    e.bindBody(data);
    
    // Validate data
    if (!data.name || !data.email) {
        throw new BadRequestError("Name and email are required");
    }
    
    // Process the contact form
    sendContactEmail(data);
    
    return e.json(200, {"success": true});
});

// Protected route requiring authentication
routerAdd("GET", "/api/profile", (e) => {
    $apis.requireAuth()(e);
    
    const info = $apis.requestInfo(e);
    const user = info.authRecord;
    
    return e.json(200, {
        "id": user.id,
        "email": user.get("email"),
        "name": user.get("name"),
        "verified": user.get("verified")
    });
});

// File upload endpoint
routerAdd("POST", "/api/upload", (e) => {
    $apis.requireAuth()(e);
    
    const info = $apis.requestInfo(e);
    const form = e.request.formValue();
    
    // Handle file upload logic
    const file = form.file;
    
    if (!file) {
        throw new BadRequestError("No file provided");
    }
    
    return e.json(200, {
        "filename": file.name,
        "size": file.size,
        "uploaded": true
    });
});
```

### Database Hooks

```javascript
// pb_hooks/main.pb.js

// Before record creation
onRecordBeforeCreateRequest((e) => {
    console.log("Creating record in:", e.record.collection().name);
    
    // Add audit fields
    e.record.set("created_by", e.requestInfo.authRecord?.id || null);
    e.record.set("created_ip", e.request.header("X-Forwarded-For") || e.request.remoteAddr);
    
    e.next();
}, "posts", "comments");

// After successful record creation
onRecordAfterCreateSuccess((e) => {
    const record = e.record;
    
    // Send notification
    if (record.collection().name === "comments") {
        notifyPostAuthor(record);
    }
    
    // Update statistics
    updateCollectionStats(record.collection().name);
    
    e.next();
});

// Before record update
onRecordBeforeUpdateRequest((e) => {
    const record = e.record;
    
    // Audit trail
    record.set("updated_by", e.requestInfo.authRecord?.id);
    record.set("updated_at", new Date().toISOString());
    
    // Prevent status changes by non-admins
    if (record.hasChangedFields("status")) {
        const user = e.requestInfo.authRecord;
        if (!user || user.get("role") !== "admin") {
            throw new ForbiddenError("Only admins can change status");
        }
    }
    
    e.next();
}, "posts");

// Before record deletion  
onRecordBeforeDeleteRequest((e) => {
    const record = e.record;
    
    // Prevent deletion of protected records
    if (record.get("protected") === true) {
        throw new BadRequestError("Cannot delete protected records");
    }
    
    // Cascade delete related records
    if (record.collection().name === "users") {
        const userPosts = $app.dao().findRecordsByFilter("posts", `author = "${record.id}"`);
        userPosts.forEach(post => {
            $app.dao().deleteRecord(post);
        });
    }
    
    e.next();
});
```

### Authentication Hooks

```javascript
// pb_hooks/auth.pb.js

// Before authentication attempt
onRecordBeforeAuthWithPasswordRequest((e) => {
    const email = e.record.get("email");
    
    // Rate limiting
    if (isRateLimited(email)) {
        throw new BadRequestError("Too many login attempts. Try again later.");
    }
    
    // Log login attempt
    console.log(`Login attempt: ${email} from ${e.request.remoteAddr}`);
    
    e.next();
}, "users");

// After successful authentication
onRecordAfterAuthWithPasswordSuccess((e) => {
    const user = e.record;
    
    // Update last login
    user.set("last_login", new Date().toISOString());
    user.set("login_count", (user.get("login_count") || 0) + 1);
    
    $app.dao().saveRecord(user);
    
    // Clear failed login attempts
    clearFailedAttempts(user.get("email"));
    
    e.next();
}, "users");

// OAuth2 authentication
onRecordAfterAuthWithOAuth2Success((e) => {
    const user = e.record;
    const provider = e.providerName;
    
    console.log(`OAuth2 login: ${user.get("email")} via ${provider}`);
    
    // Update OAuth2 info
    user.set("oauth2_provider", provider);
    user.set("last_oauth2_login", new Date().toISOString());
    
    $app.dao().saveRecord(user);
    
    e.next();
}, "users");
```

### Email Hooks

```javascript
// pb_hooks/mail.pb.js

// Customize verification email
onMailerRecordVerificationSend((e) => {
    const user = e.record;
    const actionUrl = e.meta.actionUrl;
    
    e.message.subject = "Welcome! Please verify your email";
    e.message.html = `
        <h1>Welcome ${user.get("name")}!</h1>
        <p>Please click the link below to verify your email address:</p>
        <a href="${actionUrl}">Verify Email</a>
        <p>If you didn't create an account, please ignore this email.</p>
    `;
    
    e.next();
});

// Customize password reset email
onMailerRecordPasswordResetSend((e) => {
    const user = e.record;
    const actionUrl = e.meta.actionUrl;
    
    e.message.subject = "Reset your password";
    e.message.html = `
        <h1>Password Reset Request</h1>
        <p>Hi ${user.get("name")},</p>
        <p>Click the link below to reset your password:</p>
        <a href="${actionUrl}">Reset Password</a>
        <p>This link will expire in 1 hour.</p>
        <p>If you didn't request this, please ignore this email.</p>
    `;
    
    e.next();
});

// Before sending any email
onMailerSend((e) => {
    // Add custom headers
    e.message.headers["Reply-To"] = "noreply@yourdomain.com";
    e.message.headers["X-Mailer"] = "PocketBase";
    
    // Log all outgoing emails
    console.log(`Sending email to: ${e.message.to.join(", ")}`);
    console.log(`Subject: ${e.message.subject}`);
    
    e.next();
});
```

### Database Operations (DAO)

```javascript
// pb_hooks/database.pb.js

// Finding records
function getUserPosts(userId) {
    // Find by filter
    const posts = $app.dao().findRecordsByFilter(
        "posts", 
        `author = "${userId}" && status = "published"`,
        "created DESC",
        10,  // limit
        0    // offset
    );
    
    return posts;
}

// Creating records
function createNotification(userId, message) {
    const collection = $app.dao().findCollectionByNameOrId("notifications");
    const record = new Record(collection, {
        "user": userId,
        "message": message,
        "read": false,
        "created": new Date().toISOString()
    });
    
    $app.dao().saveRecord(record);
    return record;
}

// Updating records
function markAsRead(notificationId) {
    const record = $app.dao().findRecordById("notifications", notificationId);
    record.set("read", true);
    record.set("read_at", new Date().toISOString());
    
    $app.dao().saveRecord(record);
}

// Transactions
function transferCredits(fromUserId, toUserId, amount) {
    $app.dao().runInTransaction((txDao) => {
        // Deduct from sender
        const fromUser = txDao.findRecordById("users", fromUserId);
        const currentCredits = fromUser.get("credits") || 0;
        
        if (currentCredits < amount) {
            throw new BadRequestError("Insufficient credits");
        }
        
        fromUser.set("credits", currentCredits - amount);
        txDao.saveRecord(fromUser);
        
        // Add to recipient
        const toUser = txDao.findRecordById("users", toUserId);
        const recipientCredits = toUser.get("credits") || 0;
        toUser.set("credits", recipientCredits + amount);
        txDao.saveRecord(toUser);
        
        // Create transaction record
        const transactionCollection = txDao.findCollectionByNameOrId("transactions");
        const transaction = new Record(transactionCollection, {
            "from_user": fromUserId,
            "to_user": toUserId,
            "amount": amount,
            "type": "transfer",
            "created": new Date().toISOString()
        });
        txDao.saveRecord(transaction);
    });
}
```

### HTTP Client and External APIs

```javascript
// pb_hooks/external.pb.js

// Making HTTP requests
function notifySlack(message) {
    const webhookUrl = "https://hooks.slack.com/services/YOUR/WEBHOOK/URL";
    
    const response = $http.send({
        url: webhookUrl,
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            "text": message,
            "channel": "#notifications"
        })
    });
    
    if (response.statusCode !== 200) {
        console.error("Failed to send Slack notification:", response.body);
    }
}

// Webhook handler
routerAdd("POST", "/api/webhook/stripe", (e) => {
    const signature = e.request.header("Stripe-Signature");
    const body = e.request.body;
    
    // Verify webhook signature
    if (!verifyStripeSignature(body, signature)) {
        throw new UnauthorizedError("Invalid signature");
    }
    
    const event = JSON.parse(body);
    
    switch (event.type) {
        case 'payment_intent.succeeded':
            handlePaymentSuccess(event.data.object);
            break;
        case 'payment_intent.payment_failed':
            handlePaymentFailure(event.data.object);
            break;
        default:
            console.log(`Unhandled event type: ${event.type}`);
    }
    
    return e.json(200, {"received": true});
});

// Third-party API integration
function validateAddress(address) {
    const apiKey = "YOUR_API_KEY";
    const response = $http.send({
        url: `https://api.address-validator.com/validate`,
        method: "POST", 
        headers: {
            "Authorization": `Bearer ${apiKey}`,
            "Content-Type": "application/json"
        },
        body: JSON.stringify({address})
    });
    
    if (response.statusCode === 200) {
        const data = JSON.parse(response.body);
        return data.valid;
    }
    
    return false;
}
```

### File System Operations

```javascript
// pb_hooks/files.pb.js

// Reading and writing files
function generateReport(userId) {
    const user = $app.dao().findRecordById("users", userId);
    const posts = getUserPosts(userId);
    
    const reportContent = `
User Report for ${user.get("name")}
Generated: ${new Date().toISOString()}

Total Posts: ${posts.length}
User Email: ${user.get("email")}
Account Created: ${user.get("created")}
    `;
    
    const reportPath = `/tmp/report_${userId}.txt`;
    $filesystem.writeFile(reportPath, reportContent);
    
    return reportPath;
}

// File operations
function backupData() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = `/backups/${timestamp}`;
    
    // Create backup directory
    $filesystem.createDir(backupDir);
    
    // Copy database
    if ($filesystem.exists("/pb_data/data.db")) {
        const dbContent = $filesystem.readFile("/pb_data/data.db");
        $filesystem.writeFile(`${backupDir}/data.db`, dbContent);
    }
    
    console.log(`Backup created: ${backupDir}`);
}
```

### Security Utilities

```javascript
// pb_hooks/security.pb.js

// Password utilities
function hashPassword(password) {
    return $security.hashPassword(password);
}

function verifyPassword(hash, password) {
    return $security.compareHashAndPassword(hash, password);
}

// JWT tokens
function createCustomToken(payload) {
    const secret = $app.settings().meta.appSecret;
    return $security.createJWT(payload, secret);
}

function verifyCustomToken(token) {
    const secret = $app.settings().meta.appSecret;
    return $security.parseJWT(token, secret);
}

// Random strings
function generateApiKey() {
    return $security.randomString(32);
}

function generateSecureCode() {
    return $security.randomString(8, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
}
```

### Error Handling

```javascript
// pb_hooks/errors.pb.js

// Custom error handling
routerAdd("POST", "/api/risky-operation", (e) => {
    try {
        const result = performRiskyOperation();
        return e.json(200, {"success": true, "data": result});
        
    } catch (error) {
        console.error("Operation failed:", error);
        
        // Return appropriate HTTP error
        if (error.message.includes("not found")) {
            throw new NotFoundError("Resource not found");
        } else if (error.message.includes("unauthorized")) {
            throw new UnauthorizedError("Access denied");
        } else {
            throw new InternalServerError("Operation failed");
        }
    }
});

// Global error handler
onError((e) => {
    console.error("Global error:", e.error);
    
    // Log to external service
    logToExternalService({
        error: e.error.message,
        stack: e.error.stack,
        timestamp: new Date().toISOString(),
        request: {
            method: e.request?.method,
            url: e.request?.url
        }
    });
    
    e.next();
});
```

### Module System

```javascript
// pb_hooks/utils.pb.js - Utility functions
function validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

function formatDate(date) {
    return new Date(date).toLocaleDateString();
}

function slugify(text) {
    return text
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/[\s_-]+/g, '-')
        .replace(/^-+|-+$/g, '');
}

// Export functions
module.exports = {
    validateEmail,
    formatDate,
    slugify
};

// pb_hooks/main.pb.js - Import utilities  
const utils = require(`${__hooks}/utils.pb.js`);

routerAdd("POST", "/api/register", (e) => {
    const data = new DynamicModel({
        email: "",
        name: ""
    });
    
    e.bindBody(data);
    
    if (!utils.validateEmail(data.email)) {
        throw new BadRequestError("Invalid email format");
    }
    
    // Continue with registration
    return e.json(200, {"success": true});
});
```

### Best Practices

1. **Performance**: Keep hooks lightweight and fast
2. **Error Handling**: Always implement proper error handling
3. **Logging**: Log important events for debugging
4. **Security**: Validate all inputs and check permissions
5. **Modules**: Use CommonJS modules for shared functionality
6. **Testing**: Test hooks thoroughly in development
7. **Documentation**: Comment complex logic clearly

---

## Deployment

### Systemd Service (Linux)

```ini
# /etc/systemd/system/pocketbase.service
[Unit]
Description=PocketBase
After=network.target

[Service]
Type=simple
User=pocketbase
Group=pocketbase
WorkingDirectory=/opt/pocketbase
ExecStart=/opt/pocketbase/pocketbase serve --http=127.0.0.1:8090
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

```bash
# Enable and start service
sudo systemctl enable pocketbase
sudo systemctl start pocketbase
sudo systemctl status pocketbase
```

### Docker

```dockerfile
# Dockerfile
FROM alpine:latest

RUN apk add --no-cache ca-certificates

# Download PocketBase (replace with latest version)
ADD https://github.com/pocketbase/pocketbase/releases/download/v0.20.0/pocketbase_0.20.0_linux_amd64.zip /tmp/pb.zip
RUN unzip /tmp/pb.zip -d /pb/
RUN chmod +x /pb/pocketbase

EXPOSE 8090

CMD ["/pb/pocketbase", "serve", "--http=0.0.0.0:8090"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  pocketbase:
    build: .
    ports:
      - "8090:8090"
    volumes:
      - ./pb_data:/pb/pb_data
      - ./pb_migrations:/pb/pb_migrations
      - ./pb_hooks:/pb/pb_hooks
    environment:
      - PB_ENCRYPTION_KEY=your-32-char-encryption-key-here
    restart: unless-stopped
```

### Reverse Proxy (Nginx)

```nginx
# /etc/nginx/sites-available/pocketbase
server {
    listen 80;
    server_name your-domain.com;
    
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL configuration
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    
    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    
    # Proxy to PocketBase
    location / {
        proxy_pass http://127.0.0.1:8090;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support for realtime
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
    
    # File upload size limit
    client_max_body_size 50M;
}
```

### Environment Variables

```bash
# Production environment variables
export PB_DATA_DIR="/opt/pocketbase/data"
export PB_ENCRYPTION_KEY="your-32-character-encryption-key-here"
export PB_HOOKS_DIR="/opt/pocketbase/hooks"
export PB_MIGRATIONS_DIR="/opt/pocketbase/migrations"
export PB_HOOKS_POOL=20
```

---

## Advanced Configuration

### Settings and Configuration

```bash
# Command line options
./pocketbase serve \
    --http=127.0.0.1:8090 \
    --dir=/path/to/pb_data \
    --migrationsDir=/path/to/migrations \
    --hooksDir=/path/to/hooks \
    --hooksPool=25 \
    --publicDir=/path/to/public \
    --indexFallback=true

# Environment variables (alternative to CLI flags)
PB_DATA_DIR=/path/to/pb_data
PB_ENCRYPTION_KEY=your-32-char-key
PB_HOOKS_DIR=/path/to/hooks
PB_MIGRATIONS_DIR=/path/to/migrations
PB_HOOKS_POOL=25
PB_PUBLIC_DIR=/path/to/public
PB_INDEX_FALLBACK=true
```

### Database Migrations

```javascript
// pb_migrations/1640995200_initial_schema.js
migrate((db) => {
  // Create collections, add fields, set rules, etc.
  
  const usersCollection = new Collection({
    "name": "users",
    "type": "auth",
    "options": {
      "allowEmailAuth": true,
      "allowUsernameAuth": false,
      "requireEmail": true
    },
    "listRule": null,
    "viewRule": "id = @request.auth.id",
    "createRule": "",
    "updateRule": "id = @request.auth.id",
    "deleteRule": "id = @request.auth.id",
    "schema": [
      {
        "name": "name",
        "type": "text",
        "required": false,
        "options": {
          "min": null,
          "max": null,
          "pattern": ""
        }
      }
    ]
  });

  return Dao(db).saveCollection(usersCollection);

}, (db) => {
  // Rollback
  const dao = new Dao(db);
  const collection = dao.findCollectionByNameOrId("users");
  return dao.deleteCollection(collection);
});
```

### Health Check and Monitoring

```javascript
// Built-in health check endpoint
// GET /api/health
{
    "code": 200,
    "message": "API is healthy",
    "data": {
        "canBackup": true
    }
}

// Custom health check hook
onBeforeServe((e) => {
    // Add custom health check route
    routerAdd("GET", "/api/status", (e) => {
        const stats = {
            "status": "healthy",
            "timestamp": new Date().toISOString(),
            "version": "0.20.0",
            "uptime": process.uptime ? process.uptime() : "unknown",
            "database": {
                "connected": true,
                "collections": $app.dao().findCollectionsByType("base").length
            }
        };
        
        return e.json(200, stats);
    });
    
    e.next();
});
```

### Backup and Restore

```bash
# Manual backup
./pocketbase backup /path/to/backup.zip

# Automated backup script
#!/bin/bash
BACKUP_DIR="/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/pocketbase_$DATE.zip"

mkdir -p $BACKUP_DIR
./pocketbase backup $BACKUP_FILE

# Keep only last 7 backups
find $BACKUP_DIR -name "pocketbase_*.zip" -type f -mtime +7 -delete

# Restore from backup
./pocketbase restore /path/to/backup.zip
```

### Performance Optimization

```javascript
// Database indexing via migration
migrate((db) => {
    // Add database indexes for better query performance
    db.exec(`
        CREATE INDEX IF NOT EXISTS idx_posts_status ON posts (status);
        CREATE INDEX IF NOT EXISTS idx_posts_author ON posts (author);
        CREATE INDEX IF NOT EXISTS idx_posts_created ON posts (created);
        CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);
    `);
}, (db) => {
    // Remove indexes
    db.exec(`
        DROP INDEX IF EXISTS idx_posts_status;
        DROP INDEX IF EXISTS idx_posts_author;
        DROP INDEX IF EXISTS idx_posts_created;
        DROP INDEX IF EXISTS idx_users_email;
    `);
});

// Query optimization
function getOptimizedPosts(page = 1, perPage = 20) {
    // Use specific fields to reduce data transfer
    return $app.dao().findRecordsByFilter(
        "posts",
        "status = 'published'",
        "-created",
        perPage,
        (page - 1) * perPage,
        "id,title,excerpt,created,author" // Only fetch needed fields
    );
}
```

---

This comprehensive documentation covers all aspects of PocketBase development, from basic usage to advanced server-side scripting and production deployment. Use it as a complete reference for building applications with PocketBase.
